
## 题目地址(347. 前 K 个高频元素)

https://leetcode-cn.com/problems/top-k-frequent-elements/

## 题目描述

```
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]


示例 2:

输入: nums = [1], k = 1
输出: [1]

 

提示：

1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的

 

进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。
```

## 前置知识

- 

## 公司

- 暂无

## 思路

用map记录每个值出现过的频率，在对map的key进行排序，排序依据是通过value的大小

## 关键点

-  

## 代码

- 语言支持：JavaScript

JavaScript Code:

```javascript

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function(nums, k) {
    let map = {}
    let res = []
    for(let i = 0; i<nums.length; i++) {
        map[[nums[i]]] = map[[nums[i]]] ? map[[nums[i]]] + 1 : 1
    }
    let keys = Object.keys(map)
    keys.sort((a, b) => map[b] - map[a])
    while(k > 0) {
        let key = keys.shift()
        res.push(key)
        k--
    }
    return res
};

```


**复杂度分析**

令 n 为数组长度。

- 时间复杂度：$O(longN)$
- 空间复杂度：$O(n)$


